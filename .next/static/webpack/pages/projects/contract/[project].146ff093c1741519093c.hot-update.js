"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/projects/contract/[project]",{

/***/ "./pages/projects/contract/[project].tsx":
/*!***********************************************!*\
  !*** ./pages/projects/contract/[project].tsx ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_highlight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-highlight */ \"./node_modules/react-highlight/index.js\");\n/* harmony import */ var react_highlight__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_highlight__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__);\n/* module decorator */ module = __webpack_require__.hmd(module);\nvar _jsxFileName = \"/home/andres/Documentos/Portfolio/pages/projects/contract/[project].tsx\",\n    _this = undefined;\n\n\n\n\n\nvar Contract = function Contract() {\n  var codeString = \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\n\\nimport \\\"../interfaces/IERC1155Custom.sol\\\";\\n\\n/// @title Clock auction for non-fungible tokens.\\ncontract ClockSaleMultiTokens is\\n    Ownable,\\n    Pausable,\\n    ERC1155Holder,\\n    ReentrancyGuard\\n{\\n    using Counters for Counters.Counter;\\n    using Address for address payable;\\n\\n    enum SaleStatus {\\n        Created,\\n        Successful,\\n        Canceled\\n    }\\n\\n    struct Sale {\\n        address seller;\\n        address nft;\\n        uint256 nftId;\\n        uint256 amount;\\n        uint256 priceUSD;\\n        address[] tokens;\\n        uint256 duration;\\n        uint256 startedAt;\\n        SaleStatus status;\\n    }\\n\\n    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).\\n    // Values 0-10,000 map to 0%-100%\\n    Counters.Counter public tokenIdTracker;\\n    address public feeReceiver;\\n    uint256 public ownerCut;\\n    uint256 public genesisBlock;\\n\\n    //All the sales price have to have 6 decimals\\n    uint256 public decimalsUSD = 6;\\n\\n    // Map from token ID to their corresponding auction.\\n    mapping(uint256 => Sale) public sales;\\n    // Nfts allowed in marketplace\\n    mapping(address => bool) public isAllowed;\\n\\n    // token address to priceFeed address\\n    mapping(address => address) public priceFeedsByToken;\\n    mapping(address => uint256) public decimalsByToken;\\n\\n    // Tokens allowed in the marketplace\\n    address public wcurrency;\\n\\n    event SaleCreated(\\n        uint256 indexed _auctionId,\\n        address _nft,\\n        uint256 _nftId,\\n        uint256 _amount,\\n        uint256 priceUSD,\\n        address[] _tokens,\\n        uint256 _duration,\\n        uint256 _startedAt,\\n        address _seller\\n    );\\n    event SaleSuccessful(uint256 indexed _auctionId);\\n    event BuySuccessful(\\n        uint256 indexed _auctionId,\\n        address _buyer,\\n        uint256 _cost,\\n        address _tokenUsed,\\n        uint256 _nftAmount\\n    );\\n    event SaleCancelled(uint256 indexed _auctionId);\\n    event ChangedFeeReceiver(address newReceiver);\\n\\n    constructor(\\n        address _feeReceiver,\\n        address _wcurrency,\\n        address _priceFeedW,\\n        uint256 _decimals,\\n        uint256 _ownerCut\\n    ) {\\n        require(_ownerCut <= 10000, \\\"ClockSale:OWNER_CUT\\\"); //less than 100%\\n        ownerCut = _ownerCut;\\n        feeReceiver = _feeReceiver;\\n        genesisBlock = block.number;\\n        wcurrency = _wcurrency;\\n        priceFeedsByToken[_wcurrency] = _priceFeedW;\\n        decimalsByToken[_wcurrency] = _decimals;\\n    }\\n\\n    receive() external payable {\\n        require(false, \\\"ClockSale:DONT_SEND\\\");\\n    }\\n\\n    function getSales(uint256[] memory _tokenIds)\\n        external\\n        view\\n        returns (Sale[] memory)\\n    {\\n        Sale[] memory response = new Sale[](_tokenIds.length);\\n\\n        for (uint256 i = 0; i < _tokenIds.length; i++)\\n            response[i] = sales[_tokenIds[i]];\\n\\n        return response;\\n    }\\n\\n    function getPrice(\\n        uint256 _tokenId,\\n        address tokenToGet,\\n        uint256 quantity\\n    ) public view returns (uint256) {\\n        Sale storage _auction = sales[_tokenId];\\n        require(_isOnSale(_auction), \\\"ClockSale:INVALID_SALE\\\");\\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(\\n            priceFeedsByToken[tokenToGet]\\n        );\\n        (, int256 price, , , ) = priceFeed.latestRoundData();\\n        uint256 decimals = priceFeed.decimals();\\n        // int256 price = 84679030;\\n        // uint256 decimals = 8;\\n        return\\n            (quantity *\\n                (_auction.priceUSD) *\\n                10**(decimalsByToken[tokenToGet] + decimals - decimalsUSD)) /\\n            uint256(price);\\n    }\\n\\n    function isOnSale(uint256 _tokenId) external view returns (bool) {\\n        Sale storage _auction = sales[_tokenId];\\n        return _isOnSale(_auction);\\n    }\\n\\n    function setFeeReceiver(address _feeReceiver) external onlyOwner {\\n        feeReceiver = _feeReceiver;\\n        emit ChangedFeeReceiver(feeReceiver);\\n    }\\n\\n    function setOwnerCut(uint256 _ownerCut) external onlyOwner {\\n        ownerCut = _ownerCut;\\n    }\\n\\n    function createSale(\\n        address _nftAddress,\\n        uint256 _tokenId,\\n        uint256 _priceUSD, //consider this has to be with 6 decimals in price\\n        address[] memory _tokens,\\n        uint256 _amount,\\n        uint256 _duration\\n    ) external whenNotPaused {\\n        address _seller = _msgSender();\\n\\n        require(isAllowed[_nftAddress], \\\"ClockSale:INVALID_SALE\\\");\\n        require(_owns(_nftAddress, _seller, _tokenId), \\\"ClockSale:NOT_OWNER\\\");\\n        require(_tokens.length > 0, \\\"You have to accept at least one token\\\");\\n\\n        _escrow(_nftAddress, _seller, _tokenId, _amount);\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            require(\\n                isTokenAllowed(_tokens[i]),\\n                \\\"CLOCK_AUCTION: ONE OF THE TOKENS TO PAY IS NOT ALLOWED\\\"\\n            );\\n        }\\n\\n        Sale memory _auction = Sale(\\n            _seller,\\n            _nftAddress,\\n            _tokenId,\\n            _amount,\\n            _priceUSD,\\n            _tokens,\\n            _duration,\\n            block.timestamp,\\n            SaleStatus.Created\\n        );\\n        _addSale(_auction);\\n    }\\n\\n    function buyBatch(\\n        uint256[] memory tokensId,\\n        uint256[] memory amounts,\\n        address tokenToPay\\n    ) public payable {\\n        require(\\n            tokensId.length == amounts.length,\\n            \\\"Array Length must be the same of amount and Ids\\\"\\n        );\\n        for (uint256 i = 0; i < tokensId.length; i++) {\\n            buy(tokensId[i], amounts[i], tokenToPay);\\n        }\\n    }\\n\\n    function buy(\\n        uint256 _tokenId,\\n        uint256 amount,\\n        address tokenToPay\\n    ) public payable nonReentrant whenNotPaused {\\n        Sale storage _auction = sales[_tokenId];\\n        uint256 cost = 0;\\n        for (uint256 i = 0; i < _auction.tokens.length; i++) {\\n            if (_auction.tokens[i] == tokenToPay) {\\n                cost = getPrice(_tokenId, tokenToPay, amount);\\n            }\\n        }\\n\\n        require(cost != 0, \\\"ClockSale:TOKEN_NOT_ALLOWED\\\");\\n\\n        address buyer = _msgSender();\\n        _auction.amount -= amount; //this will underflow if is x < 0\\n\\n        if (_auction.amount == 0) _finalizeSale(_tokenId);\\n\\n        if (tokenToPay == wcurrency) {\\n            require(_isOnSale(_auction), \\\"ClockSale:NOT_AVAILABLE\\\");\\n            require(msg.value >= cost, \\\"ClockSale:NOT_ENOUGH_VALUE\\\");\\n            console.log(\\\"main currency\\\", msg.value);\\n            console.log(tokenToPay, feeReceiver);\\n            uint256 ownerAmount = (cost * ownerCut) / 10000;\\n            uint256 sellAmount = cost - ownerAmount;\\n            address payable seller = payable(_auction.seller);\\n            (bool success, ) = seller.call{value: sellAmount}(\\\"\\\");\\n            require(success, \\\"Transfer failed.\\\");\\n            (bool success2, ) = feeReceiver.call{value: ownerAmount}(\\\"\\\");\\n            require(success2, \\\"Transfer failed.\\\");\\n            console.log(cost, ownerCut, address(feeReceiver).balance);\\n        } else {\\n            require(\\n                isTokenAllowed(tokenToPay),\\n                \\\"CLOCK_AUCTION: TOKEN TO PAY IS NOT ALLOWED\\\"\\n            );\\n            require(\\n                IERC20(tokenToPay).balanceOf(_msgSender()) > cost,\\n                \\\"CLOCK_AUCTION: INSUFICIENT BALANCE\\\"\\n            );\\n            require(\\n                IERC20(tokenToPay).allowance(_msgSender(), address(this)) >\\n                    cost,\\n                \\\"CLOCK_AUCTION: INSUFICIENT ALLOWANCE\\\"\\n            );\\n            require(_isOnSale(_auction), \\\"ClockSale:NOT_AVAILABLE\\\");\\n\\n            uint256 ownerAmount = (cost * ownerCut) / 10000;\\n            uint256 sellAmount = cost - ownerAmount;\\n\\n            IERC20(tokenToPay).transferFrom(\\n                _msgSender(),\\n                _auction.seller,\\n                sellAmount\\n            );\\n            IERC20(tokenToPay).transferFrom(\\n                _msgSender(),\\n                feeReceiver,\\n                ownerAmount\\n            );\\n        }\\n\\n        _transfer(_tokenId, amount, buyer);\\n        emit BuySuccessful(_tokenId, buyer, cost, tokenToPay, amount);\\n    }\\n\\n    function cancelSale(uint256 _tokenId) external {\\n        Sale storage _auction = sales[_tokenId];\\n        require(_saleExists(_auction), \\\"ClockSale:NOT_AVAILABLE\\\");\\n        require(_auction.seller == _msgSender(), \\\"ClockSale:NOT_OWNER\\\");\\n        _cancelSale(_tokenId);\\n    }\\n\\n    function setNftAllowed(address nftAddress, bool allow) external onlyOwner {\\n        isAllowed[nftAddress] = allow;\\n    }\\n\\n    function stopTrading() external onlyOwner whenNotPaused {\\n        _pause();\\n    }\\n\\n    function restartTrading() external onlyOwner whenPaused {\\n        _unpause();\\n    }\\n\\n    function updateSalePrice(uint256 saleId, uint256 newPrice)\\n        external\\n        onlyOwner\\n    {\\n        Sale storage _auction = sales[saleId];\\n        require(_saleExists(_auction), \\\"ClockSale:NOT_AVAILABLE\\\");\\n        _auction.priceUSD = newPrice;\\n    }\\n\\n    function updateSaleReceiver(uint256 saleId, address receiver)\\n        external\\n        onlyOwner\\n    {\\n        Sale storage _auction = sales[saleId];\\n        require(_saleExists(_auction), \\\"ClockSale:NOT_AVAILABLE\\\");\\n        _auction.seller = receiver;\\n    }\\n\\n    function addToken(\\n        address _token,\\n        address priceFeed,\\n        uint256 decimals\\n    ) external onlyOwner {\\n        priceFeedsByToken[_token] = priceFeed;\\n        decimalsByToken[_token] = decimals;\\n    }\\n\\n    function isTokenAllowed(address _token) public view returns (bool) {\\n        return\\n            abi.encodePacked(priceFeedsByToken[_token]).length > 0\\n                ? true\\n                : false;\\n    }\\n\\n    function _finalizeSale(uint256 tokenId) internal {\\n        Sale storage _auction = sales[tokenId];\\n        _auction.status = SaleStatus.Successful;\\n        emit SaleSuccessful(tokenId);\\n    }\\n\\n    function _isOnSale(Sale storage _auction) internal view returns (bool) {\\n        return (_saleExists(_auction) &&\\n            _auction.startedAt + _auction.duration > block.timestamp);\\n    }\\n\\n    function _saleExists(Sale storage _auction) internal view returns (bool) {\\n        return (_auction.startedAt > 0);\\n    }\\n\\n    function _getNftContract(address _nftAddress)\\n        internal\\n        pure\\n        returns (IERC1155Custom)\\n    {\\n        IERC1155Custom candidateContract = IERC1155Custom(_nftAddress);\\n        return candidateContract;\\n    }\\n\\n    function _owns(\\n        address _nftAddress,\\n        address _claimant,\\n        uint256 _tokenId\\n    ) internal view returns (bool) {\\n        IERC1155Custom _nftContract = _getNftContract(_nftAddress);\\n        return (_nftContract.balanceOf(_claimant, _tokenId) > 0);\\n    }\\n\\n    function _addSale(Sale memory _auction) internal {\\n        require(_auction.duration >= 1 minutes, \\\"ClockSale:INVALID_DURATION\\\");\\n\\n        uint256 auctionID = tokenIdTracker.current();\\n        sales[auctionID] = _auction;\\n        tokenIdTracker.increment();\\n\\n        emit SaleCreated(\\n            auctionID,\\n            _auction.nft,\\n            _auction.nftId,\\n            _auction.amount,\\n            _auction.priceUSD,\\n            _auction.tokens,\\n            _auction.duration,\\n            _auction.startedAt,\\n            _auction.seller\\n        );\\n    }\\n\\n    function _cancelSale(uint256 _tokenId) internal {\\n        Sale storage _auction = sales[_tokenId];\\n        _auction.status = SaleStatus.Canceled;\\n        _transfer(_tokenId, _auction.amount, _auction.seller);\\n        emit SaleCancelled(_tokenId);\\n    }\\n\\n    function _escrow(\\n        address _nftAddress,\\n        address _owner,\\n        uint256 _tokenId,\\n        uint256 _amount\\n    ) internal {\\n        IERC1155Custom _nftContract = _getNftContract(_nftAddress);\\n\\n        _nftContract.safeTransferFrom(\\n            _owner,\\n            address(this),\\n            _tokenId,\\n            _amount,\\n            \\\"\\\"\\n        );\\n    }\\n\\n    function _transfer(\\n        uint256 _tokenId,\\n        uint256 amount,\\n        address _receiver\\n    ) internal {\\n        Sale storage _auction = sales[_tokenId];\\n        IERC1155Custom _nftContract = _getNftContract(_auction.nft);\\n\\n        _nftContract.safeTransferFrom(\\n            address(this),\\n            _receiver,\\n            _auction.nftId,\\n            amount,\\n            \\\"\\\"\\n        );\\n    }\\n\\n    function _beforeTokenTransfer(address from, address to) internal virtual {\\n        require(\\n            address(0) == from || address(0) == to,\\n            \\\"ClockSale:CANNOT_TRANSFER\\\"\\n        );\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        override(ERC1155Receiver)\\n        returns (bool)\\n    {\\n        return super.supportsInterface(interfaceId);\\n    }\\n\\n    function emergencyWithdraw(\\n        uint256 amount,\\n        address token,\\n        address recipient\\n    ) external onlyOwner {\\n        if (token == address(0)) payable(recipient).sendValue(amount);\\n        else IERC20(token).transfer(recipient, amount);\\n    }\\n}\\n\";\n  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(\"div\", {\n    className: \"min-h-screen flex flex-col items-center py-28 bg-gray-900 gap-6\",\n    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(\"h1\", {\n      className: \"text-center text-white text-4xl font-bold\",\n      children: \"Contract Name\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 455,\n      columnNumber: 4\n    }, _this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)((react_highlight__WEBPACK_IMPORTED_MODULE_0___default()), {\n      className: \"javascript\",\n      children: codeString\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 458,\n      columnNumber: 4\n    }, _this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 454,\n    columnNumber: 3\n  }, _this);\n};\n\n_c = Contract;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Contract);\n\nvar _c;\n\n$RefreshReg$(_c, \"Contract\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9wcm9qZWN0cy9jb250cmFjdC9bcHJvamVjdF0udHN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7O0FBRUEsSUFBTUUsUUFBUSxHQUFHLFNBQVhBLFFBQVcsR0FBTTtBQUN0QixNQUFNQyxVQUFVLDJ0YkFBaEI7QUFnY0Esc0JBQ0M7QUFBSyxhQUFTLEVBQUMsaUVBQWY7QUFBQSw0QkFDQztBQUFJLGVBQVMsRUFBQywyQ0FBZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQURELGVBSUMsOERBQUMsd0RBQUQ7QUFBVyxlQUFTLEVBQUMsWUFBckI7QUFBQSxnQkFBbUNBO0FBQW5DO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFKRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FERDtBQVFBLENBemNEOztLQUFNRDtBQTBjTiwrREFBZUEsUUFBZiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYWdlcy9wcm9qZWN0cy9jb250cmFjdC9bcHJvamVjdF0udHN4P2I1ODciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEhpZ2hsaWdodCBmcm9tICdyZWFjdC1oaWdobGlnaHQnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5jb25zdCBDb250cmFjdCA9ICgpID0+IHtcblx0Y29uc3QgY29kZVN0cmluZyA9IGAvLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG5wcmFnbWEgc29saWRpdHkgXjAuOC4xMTtcblxuaW1wb3J0IFwiQG9wZW56ZXBwZWxpbi9jb250cmFjdHMvdG9rZW4vRVJDMjAvSUVSQzIwLnNvbFwiO1xuaW1wb3J0IFwiQG9wZW56ZXBwZWxpbi9jb250cmFjdHMvdXRpbHMvQ291bnRlcnMuc29sXCI7XG5pbXBvcnQgXCJAb3BlbnplcHBlbGluL2NvbnRyYWN0cy9zZWN1cml0eS9QYXVzYWJsZS5zb2xcIjtcbmltcG9ydCBcIkBvcGVuemVwcGVsaW4vY29udHJhY3RzL2FjY2Vzcy9Pd25hYmxlLnNvbFwiO1xuaW1wb3J0IFwiQG9wZW56ZXBwZWxpbi9jb250cmFjdHMvdXRpbHMvQWRkcmVzcy5zb2xcIjtcbmltcG9ydCBcIkBvcGVuemVwcGVsaW4vY29udHJhY3RzL3Rva2VuL0VSQzExNTUvdXRpbHMvRVJDMTE1NUhvbGRlci5zb2xcIjtcbmltcG9ydCBcIkBvcGVuemVwcGVsaW4vY29udHJhY3RzL3NlY3VyaXR5L1JlZW50cmFuY3lHdWFyZC5zb2xcIjtcblxuaW1wb3J0IFwiaGFyZGhhdC9jb25zb2xlLnNvbFwiO1xuXG5pbXBvcnQgXCJAY2hhaW5saW5rL2NvbnRyYWN0cy9zcmMvdjAuOC9pbnRlcmZhY2VzL0FnZ3JlZ2F0b3JWM0ludGVyZmFjZS5zb2xcIjtcblxuaW1wb3J0IFwiLi4vaW50ZXJmYWNlcy9JRVJDMTE1NUN1c3RvbS5zb2xcIjtcblxuLy8vIEB0aXRsZSBDbG9jayBhdWN0aW9uIGZvciBub24tZnVuZ2libGUgdG9rZW5zLlxuY29udHJhY3QgQ2xvY2tTYWxlTXVsdGlUb2tlbnMgaXNcbiAgICBPd25hYmxlLFxuICAgIFBhdXNhYmxlLFxuICAgIEVSQzExNTVIb2xkZXIsXG4gICAgUmVlbnRyYW5jeUd1YXJkXG57XG4gICAgdXNpbmcgQ291bnRlcnMgZm9yIENvdW50ZXJzLkNvdW50ZXI7XG4gICAgdXNpbmcgQWRkcmVzcyBmb3IgYWRkcmVzcyBwYXlhYmxlO1xuXG4gICAgZW51bSBTYWxlU3RhdHVzIHtcbiAgICAgICAgQ3JlYXRlZCxcbiAgICAgICAgU3VjY2Vzc2Z1bCxcbiAgICAgICAgQ2FuY2VsZWRcbiAgICB9XG5cbiAgICBzdHJ1Y3QgU2FsZSB7XG4gICAgICAgIGFkZHJlc3Mgc2VsbGVyO1xuICAgICAgICBhZGRyZXNzIG5mdDtcbiAgICAgICAgdWludDI1NiBuZnRJZDtcbiAgICAgICAgdWludDI1NiBhbW91bnQ7XG4gICAgICAgIHVpbnQyNTYgcHJpY2VVU0Q7XG4gICAgICAgIGFkZHJlc3NbXSB0b2tlbnM7XG4gICAgICAgIHVpbnQyNTYgZHVyYXRpb247XG4gICAgICAgIHVpbnQyNTYgc3RhcnRlZEF0O1xuICAgICAgICBTYWxlU3RhdHVzIHN0YXR1cztcbiAgICB9XG5cbiAgICAvLyBDdXQgb3duZXIgdGFrZXMgb24gZWFjaCBhdWN0aW9uLCBtZWFzdXJlZCBpbiBiYXNpcyBwb2ludHMgKDEvMTAwIG9mIGEgcGVyY2VudCkuXG4gICAgLy8gVmFsdWVzIDAtMTAsMDAwIG1hcCB0byAwJS0xMDAlXG4gICAgQ291bnRlcnMuQ291bnRlciBwdWJsaWMgdG9rZW5JZFRyYWNrZXI7XG4gICAgYWRkcmVzcyBwdWJsaWMgZmVlUmVjZWl2ZXI7XG4gICAgdWludDI1NiBwdWJsaWMgb3duZXJDdXQ7XG4gICAgdWludDI1NiBwdWJsaWMgZ2VuZXNpc0Jsb2NrO1xuXG4gICAgLy9BbGwgdGhlIHNhbGVzIHByaWNlIGhhdmUgdG8gaGF2ZSA2IGRlY2ltYWxzXG4gICAgdWludDI1NiBwdWJsaWMgZGVjaW1hbHNVU0QgPSA2O1xuXG4gICAgLy8gTWFwIGZyb20gdG9rZW4gSUQgdG8gdGhlaXIgY29ycmVzcG9uZGluZyBhdWN0aW9uLlxuICAgIG1hcHBpbmcodWludDI1NiA9PiBTYWxlKSBwdWJsaWMgc2FsZXM7XG4gICAgLy8gTmZ0cyBhbGxvd2VkIGluIG1hcmtldHBsYWNlXG4gICAgbWFwcGluZyhhZGRyZXNzID0+IGJvb2wpIHB1YmxpYyBpc0FsbG93ZWQ7XG5cbiAgICAvLyB0b2tlbiBhZGRyZXNzIHRvIHByaWNlRmVlZCBhZGRyZXNzXG4gICAgbWFwcGluZyhhZGRyZXNzID0+IGFkZHJlc3MpIHB1YmxpYyBwcmljZUZlZWRzQnlUb2tlbjtcbiAgICBtYXBwaW5nKGFkZHJlc3MgPT4gdWludDI1NikgcHVibGljIGRlY2ltYWxzQnlUb2tlbjtcblxuICAgIC8vIFRva2VucyBhbGxvd2VkIGluIHRoZSBtYXJrZXRwbGFjZVxuICAgIGFkZHJlc3MgcHVibGljIHdjdXJyZW5jeTtcblxuICAgIGV2ZW50IFNhbGVDcmVhdGVkKFxuICAgICAgICB1aW50MjU2IGluZGV4ZWQgX2F1Y3Rpb25JZCxcbiAgICAgICAgYWRkcmVzcyBfbmZ0LFxuICAgICAgICB1aW50MjU2IF9uZnRJZCxcbiAgICAgICAgdWludDI1NiBfYW1vdW50LFxuICAgICAgICB1aW50MjU2IHByaWNlVVNELFxuICAgICAgICBhZGRyZXNzW10gX3Rva2VucyxcbiAgICAgICAgdWludDI1NiBfZHVyYXRpb24sXG4gICAgICAgIHVpbnQyNTYgX3N0YXJ0ZWRBdCxcbiAgICAgICAgYWRkcmVzcyBfc2VsbGVyXG4gICAgKTtcbiAgICBldmVudCBTYWxlU3VjY2Vzc2Z1bCh1aW50MjU2IGluZGV4ZWQgX2F1Y3Rpb25JZCk7XG4gICAgZXZlbnQgQnV5U3VjY2Vzc2Z1bChcbiAgICAgICAgdWludDI1NiBpbmRleGVkIF9hdWN0aW9uSWQsXG4gICAgICAgIGFkZHJlc3MgX2J1eWVyLFxuICAgICAgICB1aW50MjU2IF9jb3N0LFxuICAgICAgICBhZGRyZXNzIF90b2tlblVzZWQsXG4gICAgICAgIHVpbnQyNTYgX25mdEFtb3VudFxuICAgICk7XG4gICAgZXZlbnQgU2FsZUNhbmNlbGxlZCh1aW50MjU2IGluZGV4ZWQgX2F1Y3Rpb25JZCk7XG4gICAgZXZlbnQgQ2hhbmdlZEZlZVJlY2VpdmVyKGFkZHJlc3MgbmV3UmVjZWl2ZXIpO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIGFkZHJlc3MgX2ZlZVJlY2VpdmVyLFxuICAgICAgICBhZGRyZXNzIF93Y3VycmVuY3ksXG4gICAgICAgIGFkZHJlc3MgX3ByaWNlRmVlZFcsXG4gICAgICAgIHVpbnQyNTYgX2RlY2ltYWxzLFxuICAgICAgICB1aW50MjU2IF9vd25lckN1dFxuICAgICkge1xuICAgICAgICByZXF1aXJlKF9vd25lckN1dCA8PSAxMDAwMCwgXCJDbG9ja1NhbGU6T1dORVJfQ1VUXCIpOyAvL2xlc3MgdGhhbiAxMDAlXG4gICAgICAgIG93bmVyQ3V0ID0gX293bmVyQ3V0O1xuICAgICAgICBmZWVSZWNlaXZlciA9IF9mZWVSZWNlaXZlcjtcbiAgICAgICAgZ2VuZXNpc0Jsb2NrID0gYmxvY2subnVtYmVyO1xuICAgICAgICB3Y3VycmVuY3kgPSBfd2N1cnJlbmN5O1xuICAgICAgICBwcmljZUZlZWRzQnlUb2tlbltfd2N1cnJlbmN5XSA9IF9wcmljZUZlZWRXO1xuICAgICAgICBkZWNpbWFsc0J5VG9rZW5bX3djdXJyZW5jeV0gPSBfZGVjaW1hbHM7XG4gICAgfVxuXG4gICAgcmVjZWl2ZSgpIGV4dGVybmFsIHBheWFibGUge1xuICAgICAgICByZXF1aXJlKGZhbHNlLCBcIkNsb2NrU2FsZTpET05UX1NFTkRcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2FsZXModWludDI1NltdIG1lbW9yeSBfdG9rZW5JZHMpXG4gICAgICAgIGV4dGVybmFsXG4gICAgICAgIHZpZXdcbiAgICAgICAgcmV0dXJucyAoU2FsZVtdIG1lbW9yeSlcbiAgICB7XG4gICAgICAgIFNhbGVbXSBtZW1vcnkgcmVzcG9uc2UgPSBuZXcgU2FsZVtdKF90b2tlbklkcy5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAodWludDI1NiBpID0gMDsgaSA8IF90b2tlbklkcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlc3BvbnNlW2ldID0gc2FsZXNbX3Rva2VuSWRzW2ldXTtcblxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UHJpY2UoXG4gICAgICAgIHVpbnQyNTYgX3Rva2VuSWQsXG4gICAgICAgIGFkZHJlc3MgdG9rZW5Ub0dldCxcbiAgICAgICAgdWludDI1NiBxdWFudGl0eVxuICAgICkgcHVibGljIHZpZXcgcmV0dXJucyAodWludDI1Nikge1xuICAgICAgICBTYWxlIHN0b3JhZ2UgX2F1Y3Rpb24gPSBzYWxlc1tfdG9rZW5JZF07XG4gICAgICAgIHJlcXVpcmUoX2lzT25TYWxlKF9hdWN0aW9uKSwgXCJDbG9ja1NhbGU6SU5WQUxJRF9TQUxFXCIpO1xuICAgICAgICBBZ2dyZWdhdG9yVjNJbnRlcmZhY2UgcHJpY2VGZWVkID0gQWdncmVnYXRvclYzSW50ZXJmYWNlKFxuICAgICAgICAgICAgcHJpY2VGZWVkc0J5VG9rZW5bdG9rZW5Ub0dldF1cbiAgICAgICAgKTtcbiAgICAgICAgKCwgaW50MjU2IHByaWNlLCAsICwgKSA9IHByaWNlRmVlZC5sYXRlc3RSb3VuZERhdGEoKTtcbiAgICAgICAgdWludDI1NiBkZWNpbWFscyA9IHByaWNlRmVlZC5kZWNpbWFscygpO1xuICAgICAgICAvLyBpbnQyNTYgcHJpY2UgPSA4NDY3OTAzMDtcbiAgICAgICAgLy8gdWludDI1NiBkZWNpbWFscyA9IDg7XG4gICAgICAgIHJldHVyblxuICAgICAgICAgICAgKHF1YW50aXR5ICpcbiAgICAgICAgICAgICAgICAoX2F1Y3Rpb24ucHJpY2VVU0QpICpcbiAgICAgICAgICAgICAgICAxMCoqKGRlY2ltYWxzQnlUb2tlblt0b2tlblRvR2V0XSArIGRlY2ltYWxzIC0gZGVjaW1hbHNVU0QpKSAvXG4gICAgICAgICAgICB1aW50MjU2KHByaWNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09uU2FsZSh1aW50MjU2IF90b2tlbklkKSBleHRlcm5hbCB2aWV3IHJldHVybnMgKGJvb2wpIHtcbiAgICAgICAgU2FsZSBzdG9yYWdlIF9hdWN0aW9uID0gc2FsZXNbX3Rva2VuSWRdO1xuICAgICAgICByZXR1cm4gX2lzT25TYWxlKF9hdWN0aW9uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRGZWVSZWNlaXZlcihhZGRyZXNzIF9mZWVSZWNlaXZlcikgZXh0ZXJuYWwgb25seU93bmVyIHtcbiAgICAgICAgZmVlUmVjZWl2ZXIgPSBfZmVlUmVjZWl2ZXI7XG4gICAgICAgIGVtaXQgQ2hhbmdlZEZlZVJlY2VpdmVyKGZlZVJlY2VpdmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPd25lckN1dCh1aW50MjU2IF9vd25lckN1dCkgZXh0ZXJuYWwgb25seU93bmVyIHtcbiAgICAgICAgb3duZXJDdXQgPSBfb3duZXJDdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlU2FsZShcbiAgICAgICAgYWRkcmVzcyBfbmZ0QWRkcmVzcyxcbiAgICAgICAgdWludDI1NiBfdG9rZW5JZCxcbiAgICAgICAgdWludDI1NiBfcHJpY2VVU0QsIC8vY29uc2lkZXIgdGhpcyBoYXMgdG8gYmUgd2l0aCA2IGRlY2ltYWxzIGluIHByaWNlXG4gICAgICAgIGFkZHJlc3NbXSBtZW1vcnkgX3Rva2VucyxcbiAgICAgICAgdWludDI1NiBfYW1vdW50LFxuICAgICAgICB1aW50MjU2IF9kdXJhdGlvblxuICAgICkgZXh0ZXJuYWwgd2hlbk5vdFBhdXNlZCB7XG4gICAgICAgIGFkZHJlc3MgX3NlbGxlciA9IF9tc2dTZW5kZXIoKTtcblxuICAgICAgICByZXF1aXJlKGlzQWxsb3dlZFtfbmZ0QWRkcmVzc10sIFwiQ2xvY2tTYWxlOklOVkFMSURfU0FMRVwiKTtcbiAgICAgICAgcmVxdWlyZShfb3ducyhfbmZ0QWRkcmVzcywgX3NlbGxlciwgX3Rva2VuSWQpLCBcIkNsb2NrU2FsZTpOT1RfT1dORVJcIik7XG4gICAgICAgIHJlcXVpcmUoX3Rva2Vucy5sZW5ndGggPiAwLCBcIllvdSBoYXZlIHRvIGFjY2VwdCBhdCBsZWFzdCBvbmUgdG9rZW5cIik7XG5cbiAgICAgICAgX2VzY3JvdyhfbmZ0QWRkcmVzcywgX3NlbGxlciwgX3Rva2VuSWQsIF9hbW91bnQpO1xuICAgICAgICBmb3IgKHVpbnQyNTYgaSA9IDA7IGkgPCBfdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXF1aXJlKFxuICAgICAgICAgICAgICAgIGlzVG9rZW5BbGxvd2VkKF90b2tlbnNbaV0pLFxuICAgICAgICAgICAgICAgIFwiQ0xPQ0tfQVVDVElPTjogT05FIE9GIFRIRSBUT0tFTlMgVE8gUEFZIElTIE5PVCBBTExPV0VEXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBTYWxlIG1lbW9yeSBfYXVjdGlvbiA9IFNhbGUoXG4gICAgICAgICAgICBfc2VsbGVyLFxuICAgICAgICAgICAgX25mdEFkZHJlc3MsXG4gICAgICAgICAgICBfdG9rZW5JZCxcbiAgICAgICAgICAgIF9hbW91bnQsXG4gICAgICAgICAgICBfcHJpY2VVU0QsXG4gICAgICAgICAgICBfdG9rZW5zLFxuICAgICAgICAgICAgX2R1cmF0aW9uLFxuICAgICAgICAgICAgYmxvY2sudGltZXN0YW1wLFxuICAgICAgICAgICAgU2FsZVN0YXR1cy5DcmVhdGVkXG4gICAgICAgICk7XG4gICAgICAgIF9hZGRTYWxlKF9hdWN0aW9uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidXlCYXRjaChcbiAgICAgICAgdWludDI1NltdIG1lbW9yeSB0b2tlbnNJZCxcbiAgICAgICAgdWludDI1NltdIG1lbW9yeSBhbW91bnRzLFxuICAgICAgICBhZGRyZXNzIHRva2VuVG9QYXlcbiAgICApIHB1YmxpYyBwYXlhYmxlIHtcbiAgICAgICAgcmVxdWlyZShcbiAgICAgICAgICAgIHRva2Vuc0lkLmxlbmd0aCA9PSBhbW91bnRzLmxlbmd0aCxcbiAgICAgICAgICAgIFwiQXJyYXkgTGVuZ3RoIG11c3QgYmUgdGhlIHNhbWUgb2YgYW1vdW50IGFuZCBJZHNcIlxuICAgICAgICApO1xuICAgICAgICBmb3IgKHVpbnQyNTYgaSA9IDA7IGkgPCB0b2tlbnNJZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYnV5KHRva2Vuc0lkW2ldLCBhbW91bnRzW2ldLCB0b2tlblRvUGF5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1eShcbiAgICAgICAgdWludDI1NiBfdG9rZW5JZCxcbiAgICAgICAgdWludDI1NiBhbW91bnQsXG4gICAgICAgIGFkZHJlc3MgdG9rZW5Ub1BheVxuICAgICkgcHVibGljIHBheWFibGUgbm9uUmVlbnRyYW50IHdoZW5Ob3RQYXVzZWQge1xuICAgICAgICBTYWxlIHN0b3JhZ2UgX2F1Y3Rpb24gPSBzYWxlc1tfdG9rZW5JZF07XG4gICAgICAgIHVpbnQyNTYgY29zdCA9IDA7XG4gICAgICAgIGZvciAodWludDI1NiBpID0gMDsgaSA8IF9hdWN0aW9uLnRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKF9hdWN0aW9uLnRva2Vuc1tpXSA9PSB0b2tlblRvUGF5KSB7XG4gICAgICAgICAgICAgICAgY29zdCA9IGdldFByaWNlKF90b2tlbklkLCB0b2tlblRvUGF5LCBhbW91bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWlyZShjb3N0ICE9IDAsIFwiQ2xvY2tTYWxlOlRPS0VOX05PVF9BTExPV0VEXCIpO1xuXG4gICAgICAgIGFkZHJlc3MgYnV5ZXIgPSBfbXNnU2VuZGVyKCk7XG4gICAgICAgIF9hdWN0aW9uLmFtb3VudCAtPSBhbW91bnQ7IC8vdGhpcyB3aWxsIHVuZGVyZmxvdyBpZiBpcyB4IDwgMFxuXG4gICAgICAgIGlmIChfYXVjdGlvbi5hbW91bnQgPT0gMCkgX2ZpbmFsaXplU2FsZShfdG9rZW5JZCk7XG5cbiAgICAgICAgaWYgKHRva2VuVG9QYXkgPT0gd2N1cnJlbmN5KSB7XG4gICAgICAgICAgICByZXF1aXJlKF9pc09uU2FsZShfYXVjdGlvbiksIFwiQ2xvY2tTYWxlOk5PVF9BVkFJTEFCTEVcIik7XG4gICAgICAgICAgICByZXF1aXJlKG1zZy52YWx1ZSA+PSBjb3N0LCBcIkNsb2NrU2FsZTpOT1RfRU5PVUdIX1ZBTFVFXCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJtYWluIGN1cnJlbmN5XCIsIG1zZy52YWx1ZSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0b2tlblRvUGF5LCBmZWVSZWNlaXZlcik7XG4gICAgICAgICAgICB1aW50MjU2IG93bmVyQW1vdW50ID0gKGNvc3QgKiBvd25lckN1dCkgLyAxMDAwMDtcbiAgICAgICAgICAgIHVpbnQyNTYgc2VsbEFtb3VudCA9IGNvc3QgLSBvd25lckFtb3VudDtcbiAgICAgICAgICAgIGFkZHJlc3MgcGF5YWJsZSBzZWxsZXIgPSBwYXlhYmxlKF9hdWN0aW9uLnNlbGxlcik7XG4gICAgICAgICAgICAoYm9vbCBzdWNjZXNzLCApID0gc2VsbGVyLmNhbGx7dmFsdWU6IHNlbGxBbW91bnR9KFwiXCIpO1xuICAgICAgICAgICAgcmVxdWlyZShzdWNjZXNzLCBcIlRyYW5zZmVyIGZhaWxlZC5cIik7XG4gICAgICAgICAgICAoYm9vbCBzdWNjZXNzMiwgKSA9IGZlZVJlY2VpdmVyLmNhbGx7dmFsdWU6IG93bmVyQW1vdW50fShcIlwiKTtcbiAgICAgICAgICAgIHJlcXVpcmUoc3VjY2VzczIsIFwiVHJhbnNmZXIgZmFpbGVkLlwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGNvc3QsIG93bmVyQ3V0LCBhZGRyZXNzKGZlZVJlY2VpdmVyKS5iYWxhbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVpcmUoXG4gICAgICAgICAgICAgICAgaXNUb2tlbkFsbG93ZWQodG9rZW5Ub1BheSksXG4gICAgICAgICAgICAgICAgXCJDTE9DS19BVUNUSU9OOiBUT0tFTiBUTyBQQVkgSVMgTk9UIEFMTE9XRURcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlcXVpcmUoXG4gICAgICAgICAgICAgICAgSUVSQzIwKHRva2VuVG9QYXkpLmJhbGFuY2VPZihfbXNnU2VuZGVyKCkpID4gY29zdCxcbiAgICAgICAgICAgICAgICBcIkNMT0NLX0FVQ1RJT046IElOU1VGSUNJRU5UIEJBTEFOQ0VcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlcXVpcmUoXG4gICAgICAgICAgICAgICAgSUVSQzIwKHRva2VuVG9QYXkpLmFsbG93YW5jZShfbXNnU2VuZGVyKCksIGFkZHJlc3ModGhpcykpID5cbiAgICAgICAgICAgICAgICAgICAgY29zdCxcbiAgICAgICAgICAgICAgICBcIkNMT0NLX0FVQ1RJT046IElOU1VGSUNJRU5UIEFMTE9XQU5DRVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVxdWlyZShfaXNPblNhbGUoX2F1Y3Rpb24pLCBcIkNsb2NrU2FsZTpOT1RfQVZBSUxBQkxFXCIpO1xuXG4gICAgICAgICAgICB1aW50MjU2IG93bmVyQW1vdW50ID0gKGNvc3QgKiBvd25lckN1dCkgLyAxMDAwMDtcbiAgICAgICAgICAgIHVpbnQyNTYgc2VsbEFtb3VudCA9IGNvc3QgLSBvd25lckFtb3VudDtcblxuICAgICAgICAgICAgSUVSQzIwKHRva2VuVG9QYXkpLnRyYW5zZmVyRnJvbShcbiAgICAgICAgICAgICAgICBfbXNnU2VuZGVyKCksXG4gICAgICAgICAgICAgICAgX2F1Y3Rpb24uc2VsbGVyLFxuICAgICAgICAgICAgICAgIHNlbGxBbW91bnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBJRVJDMjAodG9rZW5Ub1BheSkudHJhbnNmZXJGcm9tKFxuICAgICAgICAgICAgICAgIF9tc2dTZW5kZXIoKSxcbiAgICAgICAgICAgICAgICBmZWVSZWNlaXZlcixcbiAgICAgICAgICAgICAgICBvd25lckFtb3VudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90cmFuc2ZlcihfdG9rZW5JZCwgYW1vdW50LCBidXllcik7XG4gICAgICAgIGVtaXQgQnV5U3VjY2Vzc2Z1bChfdG9rZW5JZCwgYnV5ZXIsIGNvc3QsIHRva2VuVG9QYXksIGFtb3VudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuY2VsU2FsZSh1aW50MjU2IF90b2tlbklkKSBleHRlcm5hbCB7XG4gICAgICAgIFNhbGUgc3RvcmFnZSBfYXVjdGlvbiA9IHNhbGVzW190b2tlbklkXTtcbiAgICAgICAgcmVxdWlyZShfc2FsZUV4aXN0cyhfYXVjdGlvbiksIFwiQ2xvY2tTYWxlOk5PVF9BVkFJTEFCTEVcIik7XG4gICAgICAgIHJlcXVpcmUoX2F1Y3Rpb24uc2VsbGVyID09IF9tc2dTZW5kZXIoKSwgXCJDbG9ja1NhbGU6Tk9UX09XTkVSXCIpO1xuICAgICAgICBfY2FuY2VsU2FsZShfdG9rZW5JZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0TmZ0QWxsb3dlZChhZGRyZXNzIG5mdEFkZHJlc3MsIGJvb2wgYWxsb3cpIGV4dGVybmFsIG9ubHlPd25lciB7XG4gICAgICAgIGlzQWxsb3dlZFtuZnRBZGRyZXNzXSA9IGFsbG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0b3BUcmFkaW5nKCkgZXh0ZXJuYWwgb25seU93bmVyIHdoZW5Ob3RQYXVzZWQge1xuICAgICAgICBfcGF1c2UoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXN0YXJ0VHJhZGluZygpIGV4dGVybmFsIG9ubHlPd25lciB3aGVuUGF1c2VkIHtcbiAgICAgICAgX3VucGF1c2UoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVTYWxlUHJpY2UodWludDI1NiBzYWxlSWQsIHVpbnQyNTYgbmV3UHJpY2UpXG4gICAgICAgIGV4dGVybmFsXG4gICAgICAgIG9ubHlPd25lclxuICAgIHtcbiAgICAgICAgU2FsZSBzdG9yYWdlIF9hdWN0aW9uID0gc2FsZXNbc2FsZUlkXTtcbiAgICAgICAgcmVxdWlyZShfc2FsZUV4aXN0cyhfYXVjdGlvbiksIFwiQ2xvY2tTYWxlOk5PVF9BVkFJTEFCTEVcIik7XG4gICAgICAgIF9hdWN0aW9uLnByaWNlVVNEID0gbmV3UHJpY2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlU2FsZVJlY2VpdmVyKHVpbnQyNTYgc2FsZUlkLCBhZGRyZXNzIHJlY2VpdmVyKVxuICAgICAgICBleHRlcm5hbFxuICAgICAgICBvbmx5T3duZXJcbiAgICB7XG4gICAgICAgIFNhbGUgc3RvcmFnZSBfYXVjdGlvbiA9IHNhbGVzW3NhbGVJZF07XG4gICAgICAgIHJlcXVpcmUoX3NhbGVFeGlzdHMoX2F1Y3Rpb24pLCBcIkNsb2NrU2FsZTpOT1RfQVZBSUxBQkxFXCIpO1xuICAgICAgICBfYXVjdGlvbi5zZWxsZXIgPSByZWNlaXZlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUb2tlbihcbiAgICAgICAgYWRkcmVzcyBfdG9rZW4sXG4gICAgICAgIGFkZHJlc3MgcHJpY2VGZWVkLFxuICAgICAgICB1aW50MjU2IGRlY2ltYWxzXG4gICAgKSBleHRlcm5hbCBvbmx5T3duZXIge1xuICAgICAgICBwcmljZUZlZWRzQnlUb2tlbltfdG9rZW5dID0gcHJpY2VGZWVkO1xuICAgICAgICBkZWNpbWFsc0J5VG9rZW5bX3Rva2VuXSA9IGRlY2ltYWxzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVG9rZW5BbGxvd2VkKGFkZHJlc3MgX3Rva2VuKSBwdWJsaWMgdmlldyByZXR1cm5zIChib29sKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgICAgICAgYWJpLmVuY29kZVBhY2tlZChwcmljZUZlZWRzQnlUb2tlbltfdG9rZW5dKS5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICAgICAgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZmluYWxpemVTYWxlKHVpbnQyNTYgdG9rZW5JZCkgaW50ZXJuYWwge1xuICAgICAgICBTYWxlIHN0b3JhZ2UgX2F1Y3Rpb24gPSBzYWxlc1t0b2tlbklkXTtcbiAgICAgICAgX2F1Y3Rpb24uc3RhdHVzID0gU2FsZVN0YXR1cy5TdWNjZXNzZnVsO1xuICAgICAgICBlbWl0IFNhbGVTdWNjZXNzZnVsKHRva2VuSWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pc09uU2FsZShTYWxlIHN0b3JhZ2UgX2F1Y3Rpb24pIGludGVybmFsIHZpZXcgcmV0dXJucyAoYm9vbCkge1xuICAgICAgICByZXR1cm4gKF9zYWxlRXhpc3RzKF9hdWN0aW9uKSAmJlxuICAgICAgICAgICAgX2F1Y3Rpb24uc3RhcnRlZEF0ICsgX2F1Y3Rpb24uZHVyYXRpb24gPiBibG9jay50aW1lc3RhbXApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9zYWxlRXhpc3RzKFNhbGUgc3RvcmFnZSBfYXVjdGlvbikgaW50ZXJuYWwgdmlldyByZXR1cm5zIChib29sKSB7XG4gICAgICAgIHJldHVybiAoX2F1Y3Rpb24uc3RhcnRlZEF0ID4gMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2dldE5mdENvbnRyYWN0KGFkZHJlc3MgX25mdEFkZHJlc3MpXG4gICAgICAgIGludGVybmFsXG4gICAgICAgIHB1cmVcbiAgICAgICAgcmV0dXJucyAoSUVSQzExNTVDdXN0b20pXG4gICAge1xuICAgICAgICBJRVJDMTE1NUN1c3RvbSBjYW5kaWRhdGVDb250cmFjdCA9IElFUkMxMTU1Q3VzdG9tKF9uZnRBZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZUNvbnRyYWN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9vd25zKFxuICAgICAgICBhZGRyZXNzIF9uZnRBZGRyZXNzLFxuICAgICAgICBhZGRyZXNzIF9jbGFpbWFudCxcbiAgICAgICAgdWludDI1NiBfdG9rZW5JZFxuICAgICkgaW50ZXJuYWwgdmlldyByZXR1cm5zIChib29sKSB7XG4gICAgICAgIElFUkMxMTU1Q3VzdG9tIF9uZnRDb250cmFjdCA9IF9nZXROZnRDb250cmFjdChfbmZ0QWRkcmVzcyk7XG4gICAgICAgIHJldHVybiAoX25mdENvbnRyYWN0LmJhbGFuY2VPZihfY2xhaW1hbnQsIF90b2tlbklkKSA+IDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9hZGRTYWxlKFNhbGUgbWVtb3J5IF9hdWN0aW9uKSBpbnRlcm5hbCB7XG4gICAgICAgIHJlcXVpcmUoX2F1Y3Rpb24uZHVyYXRpb24gPj0gMSBtaW51dGVzLCBcIkNsb2NrU2FsZTpJTlZBTElEX0RVUkFUSU9OXCIpO1xuXG4gICAgICAgIHVpbnQyNTYgYXVjdGlvbklEID0gdG9rZW5JZFRyYWNrZXIuY3VycmVudCgpO1xuICAgICAgICBzYWxlc1thdWN0aW9uSURdID0gX2F1Y3Rpb247XG4gICAgICAgIHRva2VuSWRUcmFja2VyLmluY3JlbWVudCgpO1xuXG4gICAgICAgIGVtaXQgU2FsZUNyZWF0ZWQoXG4gICAgICAgICAgICBhdWN0aW9uSUQsXG4gICAgICAgICAgICBfYXVjdGlvbi5uZnQsXG4gICAgICAgICAgICBfYXVjdGlvbi5uZnRJZCxcbiAgICAgICAgICAgIF9hdWN0aW9uLmFtb3VudCxcbiAgICAgICAgICAgIF9hdWN0aW9uLnByaWNlVVNELFxuICAgICAgICAgICAgX2F1Y3Rpb24udG9rZW5zLFxuICAgICAgICAgICAgX2F1Y3Rpb24uZHVyYXRpb24sXG4gICAgICAgICAgICBfYXVjdGlvbi5zdGFydGVkQXQsXG4gICAgICAgICAgICBfYXVjdGlvbi5zZWxsZXJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY2FuY2VsU2FsZSh1aW50MjU2IF90b2tlbklkKSBpbnRlcm5hbCB7XG4gICAgICAgIFNhbGUgc3RvcmFnZSBfYXVjdGlvbiA9IHNhbGVzW190b2tlbklkXTtcbiAgICAgICAgX2F1Y3Rpb24uc3RhdHVzID0gU2FsZVN0YXR1cy5DYW5jZWxlZDtcbiAgICAgICAgX3RyYW5zZmVyKF90b2tlbklkLCBfYXVjdGlvbi5hbW91bnQsIF9hdWN0aW9uLnNlbGxlcik7XG4gICAgICAgIGVtaXQgU2FsZUNhbmNlbGxlZChfdG9rZW5JZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2VzY3JvdyhcbiAgICAgICAgYWRkcmVzcyBfbmZ0QWRkcmVzcyxcbiAgICAgICAgYWRkcmVzcyBfb3duZXIsXG4gICAgICAgIHVpbnQyNTYgX3Rva2VuSWQsXG4gICAgICAgIHVpbnQyNTYgX2Ftb3VudFxuICAgICkgaW50ZXJuYWwge1xuICAgICAgICBJRVJDMTE1NUN1c3RvbSBfbmZ0Q29udHJhY3QgPSBfZ2V0TmZ0Q29udHJhY3QoX25mdEFkZHJlc3MpO1xuXG4gICAgICAgIF9uZnRDb250cmFjdC5zYWZlVHJhbnNmZXJGcm9tKFxuICAgICAgICAgICAgX293bmVyLFxuICAgICAgICAgICAgYWRkcmVzcyh0aGlzKSxcbiAgICAgICAgICAgIF90b2tlbklkLFxuICAgICAgICAgICAgX2Ftb3VudCxcbiAgICAgICAgICAgIFwiXCJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfdHJhbnNmZXIoXG4gICAgICAgIHVpbnQyNTYgX3Rva2VuSWQsXG4gICAgICAgIHVpbnQyNTYgYW1vdW50LFxuICAgICAgICBhZGRyZXNzIF9yZWNlaXZlclxuICAgICkgaW50ZXJuYWwge1xuICAgICAgICBTYWxlIHN0b3JhZ2UgX2F1Y3Rpb24gPSBzYWxlc1tfdG9rZW5JZF07XG4gICAgICAgIElFUkMxMTU1Q3VzdG9tIF9uZnRDb250cmFjdCA9IF9nZXROZnRDb250cmFjdChfYXVjdGlvbi5uZnQpO1xuXG4gICAgICAgIF9uZnRDb250cmFjdC5zYWZlVHJhbnNmZXJGcm9tKFxuICAgICAgICAgICAgYWRkcmVzcyh0aGlzKSxcbiAgICAgICAgICAgIF9yZWNlaXZlcixcbiAgICAgICAgICAgIF9hdWN0aW9uLm5mdElkLFxuICAgICAgICAgICAgYW1vdW50LFxuICAgICAgICAgICAgXCJcIlxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9iZWZvcmVUb2tlblRyYW5zZmVyKGFkZHJlc3MgZnJvbSwgYWRkcmVzcyB0bykgaW50ZXJuYWwgdmlydHVhbCB7XG4gICAgICAgIHJlcXVpcmUoXG4gICAgICAgICAgICBhZGRyZXNzKDApID09IGZyb20gfHwgYWRkcmVzcygwKSA9PSB0byxcbiAgICAgICAgICAgIFwiQ2xvY2tTYWxlOkNBTk5PVF9UUkFOU0ZFUlwiXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3VwcG9ydHNJbnRlcmZhY2UoYnl0ZXM0IGludGVyZmFjZUlkKVxuICAgICAgICBwdWJsaWNcbiAgICAgICAgdmlld1xuICAgICAgICBvdmVycmlkZShFUkMxMTU1UmVjZWl2ZXIpXG4gICAgICAgIHJldHVybnMgKGJvb2wpXG4gICAge1xuICAgICAgICByZXR1cm4gc3VwZXIuc3VwcG9ydHNJbnRlcmZhY2UoaW50ZXJmYWNlSWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVtZXJnZW5jeVdpdGhkcmF3KFxuICAgICAgICB1aW50MjU2IGFtb3VudCxcbiAgICAgICAgYWRkcmVzcyB0b2tlbixcbiAgICAgICAgYWRkcmVzcyByZWNpcGllbnRcbiAgICApIGV4dGVybmFsIG9ubHlPd25lciB7XG4gICAgICAgIGlmICh0b2tlbiA9PSBhZGRyZXNzKDApKSBwYXlhYmxlKHJlY2lwaWVudCkuc2VuZFZhbHVlKGFtb3VudCk7XG4gICAgICAgIGVsc2UgSUVSQzIwKHRva2VuKS50cmFuc2ZlcihyZWNpcGllbnQsIGFtb3VudCk7XG4gICAgfVxufVxuYDtcblx0cmV0dXJuIChcblx0XHQ8ZGl2IGNsYXNzTmFtZT1cIm1pbi1oLXNjcmVlbiBmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlciBweS0yOCBiZy1ncmF5LTkwMCBnYXAtNlwiPlxuXHRcdFx0PGgxIGNsYXNzTmFtZT1cInRleHQtY2VudGVyIHRleHQtd2hpdGUgdGV4dC00eGwgZm9udC1ib2xkXCI+XG5cdFx0XHRcdENvbnRyYWN0IE5hbWVcblx0XHRcdDwvaDE+XG5cdFx0XHQ8SGlnaGxpZ2h0IGNsYXNzTmFtZT1cImphdmFzY3JpcHRcIj57Y29kZVN0cmluZ308L0hpZ2hsaWdodD5cblx0XHQ8L2Rpdj5cblx0KTtcbn07XG5leHBvcnQgZGVmYXVsdCBDb250cmFjdDtcbiJdLCJuYW1lcyI6WyJIaWdobGlnaHQiLCJSZWFjdCIsIkNvbnRyYWN0IiwiY29kZVN0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/projects/contract/[project].tsx\n");

/***/ })

});