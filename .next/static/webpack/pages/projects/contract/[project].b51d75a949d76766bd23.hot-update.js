"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/projects/contract/[project]",{

/***/ "./pages/projects/contract/[project].tsx":
/*!***********************************************!*\
  !*** ./pages/projects/contract/[project].tsx ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var contractsProjects_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! contractsProjects.json */ \"./contractsProjects.json\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/router */ \"./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__);\n/* module decorator */ module = __webpack_require__.hmd(module);\nvar _jsxFileName = \"/home/andres/Documentos/Portfolio/pages/projects/contract/[project].tsx\",\n    _this = undefined,\n    _s = $RefreshSig$();\n\n\n\n\n\n\nvar Contract = function Contract() {\n  _s();\n\n  var _useRouter = (0,next_router__WEBPACK_IMPORTED_MODULE_1__.useRouter)(),\n      query = _useRouter.query;\n\n  var contract = contractsProjects_json__WEBPACK_IMPORTED_MODULE_0__.filter(function (contract, i) {\n    return query.project == contract.link;\n  });\n  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(\"div\", {\n    className: \"min-h-screen flex flex-col items-center py-28 bg-gray-900 gap-6\",\n    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(\"h1\", {\n      className: \"text-center text-white text-4xl font-bold\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 12,\n      columnNumber: 4\n    }, _this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(\"div\", {\n      className: \"flex flex-col gap-4\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 13,\n      columnNumber: 4\n    }, _this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 11,\n    columnNumber: 3\n  }, _this);\n};\n\n_s(Contract, \"wby5GzzI23pLfTlf5I7v7XLG1RQ=\", false, function () {\n  return [next_router__WEBPACK_IMPORTED_MODULE_1__.useRouter];\n});\n\n_c = Contract;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Contract);\n\nvar _c;\n\n$RefreshReg$(_c, \"Contract\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9wcm9qZWN0cy9jb250cmFjdC9bcHJvamVjdF0udHN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7OztBQUVBLElBQU1HLFFBQVEsR0FBRyxTQUFYQSxRQUFXLEdBQU07QUFBQTs7QUFDdEIsbUJBQWtCRixzREFBUyxFQUEzQjtBQUFBLE1BQVFHLEtBQVIsY0FBUUEsS0FBUjs7QUFDQSxNQUFNQyxRQUFRLEdBQUdMLDBEQUFBLENBQ2hCLFVBQUNLLFFBQUQsRUFBV0UsQ0FBWDtBQUFBLFdBQWlCSCxLQUFLLENBQUNJLE9BQU4sSUFBaUJILFFBQVEsQ0FBQ0ksSUFBM0M7QUFBQSxHQURnQixDQUFqQjtBQUdBLHNCQUNDO0FBQUssYUFBUyxFQUFDLGlFQUFmO0FBQUEsNEJBQ0M7QUFBSSxlQUFTLEVBQUM7QUFBZDtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBREQsZUFFQztBQUFLLGVBQVMsRUFBQztBQUFmO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFGRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FERDtBQU1BLENBWEQ7O0dBQU1OO1VBQ2FGOzs7S0FEYkU7QUFZTiwrREFBZUEsUUFBZiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9wYWdlcy9wcm9qZWN0cy9jb250cmFjdC9bcHJvamVjdF0udHN4P2I1ODciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNvbnRyYWN0cyBmcm9tICdjb250cmFjdHNQcm9qZWN0cy5qc29uJztcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJ25leHQvcm91dGVyJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxuY29uc3QgQ29udHJhY3QgPSAoKSA9PiB7XG5cdGNvbnN0IHsgcXVlcnkgfSA9IHVzZVJvdXRlcigpO1xuXHRjb25zdCBjb250cmFjdCA9IGNvbnRyYWN0cy5maWx0ZXIoXG5cdFx0KGNvbnRyYWN0LCBpKSA9PiBxdWVyeS5wcm9qZWN0ID09IGNvbnRyYWN0Lmxpbmtcblx0KTtcblx0cmV0dXJuIChcblx0XHQ8ZGl2IGNsYXNzTmFtZT1cIm1pbi1oLXNjcmVlbiBmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlciBweS0yOCBiZy1ncmF5LTkwMCBnYXAtNlwiPlxuXHRcdFx0PGgxIGNsYXNzTmFtZT1cInRleHQtY2VudGVyIHRleHQtd2hpdGUgdGV4dC00eGwgZm9udC1ib2xkXCI+e308L2gxPlxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC00XCI+e308L2Rpdj5cblx0XHQ8L2Rpdj5cblx0KTtcbn07XG5leHBvcnQgZGVmYXVsdCBDb250cmFjdDtcbiJdLCJuYW1lcyI6WyJjb250cmFjdHMiLCJ1c2VSb3V0ZXIiLCJSZWFjdCIsIkNvbnRyYWN0IiwicXVlcnkiLCJjb250cmFjdCIsImZpbHRlciIsImkiLCJwcm9qZWN0IiwibGluayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/projects/contract/[project].tsx\n");

/***/ }),

/***/ "./contractsProjects.json":
/*!********************************!*\
  !*** ./contractsProjects.json ***!
  \********************************/
/***/ (function(module) {

module.exports = JSON.parse('[{"name":"Enders Gate Marketplace","contractName":"ClockSaleMultiTokens.sol","link":"projects/contract/eg_marketplace","image":"/img/eg_marketplace.png","codeDescription":{"paragraphs":[{"text":"This smart contract, named ClockSaleMultiTokens, is a decentralized marketplace for buying and selling non-fungible tokens (NFTs) using multiple types of ERC20 tokens as payment. It inherits from the OpenZeppelin\'s Ownable, Pausable, ERC1155Holder, and ReentrancyGuard contracts. The contract uses Chainlink\'s AggregatorV3Interface to fetch token prices and Hardhat\'s console library for logging."},{"text":"Key features of the ClockSaleMultiTokens contract:","subTexts":["It maintains a mapping of token IDs to their corresponding sales and a mapping of token addresses to price feed addresses.","The contract owner can set a fee that they receive for each sale, which is calculated as a percentage of the total sale price.","The contract allows NFTs to be listed for sale with a specified price in USD, a list of accepted ERC20 tokens for payment, and a sale duration.","Buyers can purchase NFTs with their chosen ERC20 token, provided that the token is accepted by the seller.","The contract supports batch buying of multiple NFTs in one transaction.","Sellers can cancel their sales, and the contract owner can stop and restart trading in the marketplace.","The contract has a feature for emergency withdrawal of funds."]},{"text":"Events emitted by the contract include SaleCreated, SaleSuccessful, BuySuccessful, SaleCancelled, and ChangedFeeReceiver."},{"text":"The constructor takes the fee receiver\'s address, wrapped currency address, price feed address for wrapped currency, decimals for wrapped currency, and owner\'s cut as arguments. It ensures that the owner\'s cut is less than or equal to 100%."},{"text":"The contract supports batch buying of multiple NFTs in one transaction."},{"text":"Some important functions in the contract are:","subTexts":["createSale: allows users to list their NFTs for sale by specifying the NFT address, token ID, price in USD, accepted tokens, amount, and duration.","buy and buyBatch: allows users to buy NFTs listed for sale using their chosen ERC20 token.","cancelSale: allows sellers to cancel their sales.","setNftAllowed: allows the contract owner to specify which NFT contracts are allowed in the marketplace.","stopTrading and restartTrading: allows the contract owner to pause and unpause the marketplace.","addToken: allows the contract owner to add a new ERC20 token and its associated price feed and decimals.","emergencyWithdraw: allows the contract owner to withdraw funds in case of an emergency."]}]}},{"name":"Enders Gate Packs Shop","contractName":"ClockSaleOwnable.sol","link":"/contracts/eg_shop","image":"/img/shop.png","codeDescription":{"paragraphs":[{"text":"This is a smart contract named ClockSaleOwnable for a marketplace to facilitate the sale of non-fungible tokens (NFTs). It is built using the Solidity programming language and is based on the OpenZeppelin contracts and Chainlink. It is also an ERC1155 contract, which allows the trading of multiple NFT types within a single contract."},{"text":"Key features of this smart contract include:","subTexts":["The contract is Ownable, Pausable, ERC1155Holder, and ReentrancyGuard, which provide the contract with ownership functionality, the ability to be paused, the capability to hold ERC1155 tokens, and protection against reentrancy attacks, respectively.","The ClockSaleOwnable constructor requires the fee receiver, wrapped currency, wrapped currency price feed, decimals, and owner cut as arguments. The constructor sets various contract properties, such as the fee receiver, genesis block, wrapped currency, price feeds, and decimals for tokens.","The contract allows the owner to create sales by specifying the NFT address, token ID, price in USD, accepted tokens, amount, and duration. The sale is represented by a struct called Sale with various attributes.","The contract includes functions to buy NFTs, either individually or in batches, using specified tokens.","The contract allows the owner to cancel a sale, update the sale price, and update the sale receiver.","The contract provides functions to add, remove, or check if an NFT contract is allowed in the marketplace.","The contract allows the owner to stop and restart trading.","The contract includes a function to perform an emergency withdrawal of funds in case of any issues.","The contract emits various events to track the creation, success, and cancellation of sales, as well as successful buys and changes in the fee receiver."]},{"text":"This smart contract can be used to create a marketplace for trading NFTs, with support for different tokens and customizable fees. The marketplace also provides various features for managing sales, adjusting pricing, and maintaining a secure trading environment."}]}},{"name":"CoCo Bottle Collection","contractName":"BottleCollection.sol","link":"/contracts/bottle_collection","image":"/img/coco.png","codeDescription":{"paragraphs":[{"text":"This smart contract named ClockSaleOwnable for a marketplace to facilitate the sale of non-fungible tokens (NFTs). It is built using the Solidity programming language and is based on the OpenZeppelin contracts and Chainlink. It is also an ERC1155 contract, which allows the trading of multiple NFT types within a single contract."},{"text":"Key features of this smart contract include:","subTexts":["The contract is Ownable, Pausable, ERC1155Holder, and ReentrancyGuard, which provide the contract with ownership functionality, the ability to be paused, the capability to hold ERC1155 tokens, and protection against reentrancy attacks, respectively.","The ClockSaleOwnable constructor requires the fee receiver, wrapped currency, wrapped currency price feed, decimals, and owner cut as arguments. The constructor sets various contract properties, such as the fee receiver, genesis block, wrapped currency, price feeds, and decimals for tokens.","The contract allows the owner to create sales by specifying the NFT address, token ID, price in USD, accepted tokens, amount, and duration. The sale is represented by a struct called Sale with various attributes.","The contract includes functions to buy NFTs, either individually or in batches, using specified tokens.","The contract allows the owner to cancel a sale, update the sale price, and update the sale receiver.","The contract provides functions to add, remove, or check if an NFT contract is allowed in the marketplace.","The contract allows the owner to stop and restart trading.","The contract includes a function to perform an emergency withdrawal of funds in case of any issues.","The contract emits various events to track the creation, success, and cancellation of sales, as well as successful buys and changes in the fee receiver."]},{"text":"This smart contract can be used to create a marketplace for trading NFTs, with support for different tokens and customizable fees. The marketplace also provides various features for managing sales, adjusting pricing, and maintaining a secure trading environment."}]}},{"name":"Enders Pass Pack Collection","contractName":"ERC721SeaDrop.sol","link":"/contracts/eg_pass_packs","image":"/img/CommonPass.png","codeDescription":{"paragraphs":[{"text":"This Solidity contract, named ERC721SeaDrop, is an implementation of a Non-Fungible Token (NFT) contract based on the ERC721 standard. It includes additional functionality for \'SeaDrop\', which is a mechanism for distributing NFTs. The contract imports and utilizes other libraries and contracts, such as ReentrancyGuard, IERC165, and DefaultOperatorFilterer."},{"text":"The main functionality of the contract includes:","subTexts":["Constructor: Initializes the contract with a name, symbol, and an array of allowed SeaDrop addresses.","mintSeaDrop: Mints a specific quantity of tokens for a minter address, ensuring the allowed SeaDrop contract and max supply constraints are not violated.","updateAllowedSeaDrop: Allows the owner to update the list of allowed SeaDrop contracts.","getOwnerTokens: Returns an array of token IDs owned by a specific address.","updatePublicDrop, updateAllowList, updateTokenGatedDrop, updateDropURI, updateCreatorPayoutAddress, updateAllowedFeeRecipient, updateSignedMintValidationParams, updatePayer: Functions for updating various SeaDrop parameters.","getMintStats: Returns the number of tokens minted by an address, the current total supply, and the maximum supply.","supportsInterface: Determines if the contract supports a specific interface ID.","setApprovalForAll, approve: Functions for setting and updating operator approvals, with additional checks for allowed operators.","transferFrom, safeTransferFrom: Functions for transferring tokens between addresses, with additional checks for allowed operators and updates to the ownerTokens mapping."]},{"text":"Note that this contract uses several modifiers and internal functions to ensure that only allowed SeaDrop contracts, the owner, or the contract itself can call specific functions. Additionally, it keeps track of the owner\'s tokens using the ownerTokens mapping."}]}}]');

/***/ })

});